//$Id$
//------------------------------------------------------------------------------
//                              RandomNumber
//------------------------------------------------------------------------------
// GMAT: General Mission Analysis Tool
//
// **Legal**
//
// Developed by Dr. Matthew P. Wilkins, Schafer Corporation
//
// Author: Matthew P. Wilkins
// Created: 2008/09/08
//
/**
 * GMAT's Random Number Class
 *
 * This class implements the double precision SIMD oriented Fast 
 * Mersenne Twister pseudorandom number generator (dSFMT) version 2.1. 
 *
 * SFMT is a new variant of Mersenne Twister (MT) introduced by Mutsuo Saito and 
 * Makoto Matsumoto in 2006. The algorithm was reported at MCQMC 2006 
 * (http://mcqmc.uni-ulm.de/). The article was published in the proceedings of 
 * MCQMC2006. (see Prof. Matsumoto's Papers on random number generation.)
 *
 * SFMT is a Linear Feedbacked Shift Register (LFSR) generator that generates 
 * a 128-bit pseudorandom integer at one step. SFMT is designed with recent 
 * parallelism of modern CPUs, such as multi-stage pipelining and SIMD 
 * (e.g. 128-bit integer) instructions. It supports 32-bit and 64-bit integers, 
 * as well as double precision floating point as output.
 * 
 * SFMT is much faster than MT, in most platforms. Not only the speed, but also 
 * the dimensions of equidistributions at v-bit precision are improved. 
 * In addition, recovery from 0-excess initial state is much faster. See 
 * Master's Thesis of Mutsuo Saito for detail.
 *
 * This program is based on the IEEE Standard for Binary Floating-Point 
 * Arithmetic (ANSI/IEEE Std 754-1985) format. dSFMT ver. 2.xx is completely 
 * different from dSFMT ver. 1.xx. The recursion formula is changed and the 
 * output sequences are changed. This version uses structure of C language. 
 * Don't use different DSFMT_MEXP for compiling dSFMT.c and your program. 
 * This Project provides pseudorandom number generators of various 
 * Mersenne Prime Period: from 2521-1 to 2216091-1.
 *
 * The purpose of dSFMT is to speed up the generation by avoiding the expensive 
 * conversion of integer to double (floating point). dSFMT directly generates 
 * double precision floating point pseudorandom numbers which have the IEEE 
 * Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985) format. 
 * dSFMT is only available on the CPUs which use IEEE 754 format double precision 
 * floating point numbers.
 * 
 * dSFMT doesn't support integer outputs. dSFMT supports the output of double 
 * precision floating point pseudorandom numbers which distribute in the range 
 * of [1, 2), [0, 1), (0, 1] and (0, 1). And it also supports the various 
 * periods form 2607-1 to 2132049-1. (dSFMT ver. 2.1 supports the periods 
 * from 2521-1 to 2216091-1.)
 *
 * To compute a normally distributed Gaussian random deviate (zero mean, 
 * unit var) Hormann and Derflinger's transformed rejection with decomposition
 * is utilized. "Theoretical considerations and empirical results show that the 
 * one-dimensional quality of non-uniform random numbers is bad and the 
 * discrepancy is high when they are generated by the ratio of uniforms method 
 * combined with linear congruential generators. This observation motivates the 
 * suggestion to replace the ratio of uniforms method by transformed rejection 
 * (also called exact approximation or almost exact inversion), as the above 
 * problem does not occur for this method. Using the function 
 * $G(x) =\left( \frac{a}{1-x}+b\right)x $ with appropriate $a$ and $b$ as 
 * approximation of the inverse distribution function the transformed rejection 
 * method can be used for the same distributions as the ratio of uniforms 
 * method. The resulting algorithms for the normal, the exponential and the 
 * t-distribution are short and easy to implement. Looking at the number of 
 * uniform deviates required, at the code length and at the speed the suggested 
 * algorithms are superior to the ratio of uniforms method and compare well 
 * with other algorithms suggested in literature."
 * 
 * References
 *
 * Mutsuo Saito and Makoto Matsumoto, "SIMD-oriented Fast Mersenne Twister: a 
 * 128-bit Pseudorandom Number Generator", Monte Carlo and Quasi-Monte Carlo 
 * Methods 2006, Springer, 2008, pp. 607--622. DOI:10.1007/978-3-540-74496-2_36
 *
 * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/sfmt.pdf
 * 
 * M. Matsumoto and T. Nishimura, "Mersenne Twister: A 623-dimensionally 
 * equidistributed uniform pseudorandom number generator", ACM Trans. on 
 * Modeling and Computer Simulation Vol. 8, No. 1, January pp.3-30 (1998) 
 * DOI:10.1145/272991.272995
 * 
 * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf
 *
 * Hormann, Wolfgang and Derflinger, Gerhard. "The Tranformed Rejection Method
 * for Generating Random Variables, an Alternative to the Ration of Uniforms
 * Method." Communications in Statistics: Simulation and Computation 23, 3, 1994
 *
 * http://statmath.wu-wien.ac.at/papers/94-01-18.wh-der.ps.gz
 *
 */
//------------------------------------------------------------------------------

#include "RandomNumber.hpp"

//------------------------------------------------------------------------------
// RandomNumber()
//------------------------------------------------------------------------------
/**
 * Class constructor that seeds the generator using the clock.
 *
 */
//------------------------------------------------------------------------------
RandomNumber::RandomNumber()
{

    unsigned int clockSeed = time(NULL);

    dsfmt_init_gen_rand(&dsfmt, clockSeed);
    
}

//------------------------------------------------------------------------------
// RandomNumber(RandomNumber myRand, Integer numSeeds)
//------------------------------------------------------------------------------
/**
 * Class constructor that seeds the generator using the clock.
 *
 */
//------------------------------------------------------------------------------
RandomNumber::RandomNumber(RandomNumber myRand, Integer numSeeds)
{
    if(numSeeds == 1)
    {
	dsfmt_init_gen_rand(&dsfmt, myRand.UniformInt());
    }
    else
    {
        unsigned int mySeedArray[numSeeds];

	// Generate N uniformly distributed numbers and store them in an array
	myRand.UniformArray(mySeedArray, numSeeds);
    
	// Seed this generator
	dsfmt_init_by_array(&dsfmt, mySeedArray, numSeeds);
    }
}

//------------------------------------------------------------------------------
// RandomNumber(const unsigned int mySeed)
//------------------------------------------------------------------------------
/**
 * Class constructor that seeds the generator using a specified seed value.
 *
 */
//------------------------------------------------------------------------------
RandomNumber::RandomNumber(unsigned int mySeed)
{
    dsfmt_init_gen_rand(&dsfmt, mySeed);
}

//------------------------------------------------------------------------------
// RandomNumber(unsigned int *mySeedArray, Integer arraySize)
//------------------------------------------------------------------------------
/**
 * Class constructor that seeds the generator using an array of seed values.
 *
 */
//------------------------------------------------------------------------------
RandomNumber::RandomNumber(unsigned int *mySeedArray, Integer arraySize)
{
    dsfmt_init_by_array(&dsfmt, mySeedArray, arraySize);
}

//------------------------------------------------------------------------------
// ~RandomNumber()
//------------------------------------------------------------------------------
/**
 * Class destructor.
 *
 */
//------------------------------------------------------------------------------
RandomNumber::~RandomNumber()
{
}


//------------------------------------------------------------------------------
//  void Seed(unsigned int s)
//------------------------------------------------------------------------------
/**
 *  Set the seed for the random number generator using a specified value.
 *
 *  @param <idum2> input seed
 */
//------------------------------------------------------------------------------
void RandomNumber::Seed(unsigned int s)
{
    dsfmt_init_gen_rand(&dsfmt, s);
}


//------------------------------------------------------------------------------
//  void SeedByArray(unsigned int s)
//------------------------------------------------------------------------------
/**
 *  Set the seed for the random number generator using a specified value.
 *
 *  @param <idum2> input seed
 */
//------------------------------------------------------------------------------
void RandomNumber::SeedByArray(unsigned int *mySeed, Integer arraySize)
{
    dsfmt_init_by_array(&dsfmt, mySeed, arraySize);
}

//------------------------------------------------------------------------------
//  void ClockSeed()
//------------------------------------------------------------------------------
/**
 * Set the seed value based upon the current clock time.
 */
//------------------------------------------------------------------------------
void RandomNumber::ClockSeed()
{

    unsigned int clockSeed = time(NULL);

    dsfmt_init_gen_rand(&dsfmt, clockSeed);

}

//------------------------------------------------------------------------------
//  unsigned int UniformInt()
//------------------------------------------------------------------------------
/**
 *  Returns an unsigned 32-bit integer. This should only be used to seed.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
unsigned int RandomNumber::UniformInt()
{
     return dsfmt_genrand_uint32(&dsfmt);
}

//------------------------------------------------------------------------------
//  Real Uniform()
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range [0,1)
 *  The range includes 0.0 but excludes 1.0;
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::Uniform()
{
     return dsfmt_genrand_close_open(&dsfmt);
}

//------------------------------------------------------------------------------
//  Real UniformPrimitive()
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range [1,2).
 *  The range includes 1.0 but excludes 2.0. This is the primitive MT generator
 *  that all other function calls are based upon. This is the fastest method
 *  for generating a random variate.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::UniformPrimitive()
{
     return dsfmt_genrand_close1_open2(&dsfmt);
}

//------------------------------------------------------------------------------
//  Real UniformOpenOpen()
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (0,1)
 *  The range excludes both 0.0 and 1.0. This is useful when you need to
 *  avoid a singularity at 0 or 1.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::UniformOpenOpen()
{
     return dsfmt_genrand_open_open(&dsfmt);
}

 //------------------------------------------------------------------------------
//  Real UniformOpenClosed()
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (0,1]
 *  The range excludes 0.0 but includes 1.0. This is useful when you need to
 *  avoid a singularity at 0.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::UniformOpenClosed()
{
     return dsfmt_genrand_open_close(&dsfmt);
}

//------------------------------------------------------------------------------
//  Real Uniform(Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range [a,b)
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::Uniform(const Real a, const Real b)
{
     return a + (b - a)*dsfmt_genrand_close_open(&dsfmt);
}

//------------------------------------------------------------------------------
//  Real UniformOpenOpen(Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (a,b)
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::UniformOpenOpen(const Real a, const Real b)
{
     return a + (b - a)*dsfmt_genrand_open_open(&dsfmt);
}

//------------------------------------------------------------------------------
//  Real UniformOpenClosed(Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an uniformly distributed random deviate in the range (a,b]
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::UniformOpenClosed(const Real a, const Real b)
{
     return a + (b - a)*dsfmt_genrand_open_close(&dsfmt);
}

//------------------------------------------------------------------------------
//  Real Gaussian()
//------------------------------------------------------------------------------
/**
 *  Returns a normally distributed Gaussian random deviate (zero mean, unit var)
 *  using transformed rejection with decomposition by Wolfgang Hormann.
 *
 *  Hormann, Wolfgang and Derflinger, Gerhard. "The Tranformed Rejection Method
 *  for Generating Random Variables, an Alternative to the Ratio of Uniforms
 *  Method." Communications in Statistics: Simulation and Computation 23, 3, 1994.
 *
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::Gaussian()
{
    const Real ur = 0.4359971734;
    const Real vr = 0.9296123611;
    const Real a = 0.062794;
    const Real b = 2.530885;
    const Real alpha = 0.8904302215;
    const Real alpha_sq2pi_inv = alpha/GmatMathUtil::Sqrt(GmatMathUtil::TWO_PI);

    bool flag;

    do
    {
	
	flag = false;
	
	Real V = UniformOpenOpen();
    
	if( V <= 2*ur*vr )
	{
	    return G(V/vr-ur,a,b);
	}
	else
	{
	    Real U;  
	 
	    if ( V >= vr )
	    {	
		U = UniformOpenOpen(-0.5,0.5);
	    }
	    else
	    {
		U = V/vr - (ur + 0.5);
		U = 0.5*GmatMathUtil::SignOf(U)-U;
		V = UniformOpenOpen(0.0,vr);
	    }
	
	    Real gu = G(U,a,b);
	
	    if (((V*GmatMathUtil::Exp(0.5*gu*gu)) - b*alpha_sq2pi_inv)*
		(0.25-GmatMathUtil::Abs(U)+U*U) <= a*alpha_sq2pi_inv)
	    {
		return gu;
	    }
	    else
	    {	
	       flag = true;
	    }
	}
	
    } 
    while (flag);
    
    return 0;
    
}

//------------------------------------------------------------------------------
//  Real G(const Real x, const Real a, const Real b)
//------------------------------------------------------------------------------
/**
 *  Inline function that is required for the transformed rejection with
 *  decomposition method.
 *
 *  @param <x>  The independent parameter of the function
 *  @param <a>  Optimized parameter specific to distribution
 *  @param <b>  Optimized parameter specific to distribution
 *  @return G(x)
 *
 */
//------------------------------------------------------------------------------
inline Real RandomNumber::G(Real x, Real a, Real b)
{
    return (2.0*a/(0.5-GmatMathUtil::Abs(x))+b)*x;
}

//------------------------------------------------------------------------------
//  Real Gaussian(const Real mean, const Real stdev)
//------------------------------------------------------------------------------
/**
 *  Returns a normally distributed Gaussian random deviate (zero mean, unit var)
 *  using the transformed rejection method.
 *
 *  @param <mean> Mean of Gaussian distribution
 *  @param <stdev> Standard deviation of Gaussian distribution
 *  @return The random deviate.
 *
 */
//------------------------------------------------------------------------------
Real RandomNumber::Gaussian(const Real mean, const Real stdev)
{
    return Gaussian() * stdev + mean;
}

//------------------------------------------------------------------------------
//  void UniformArray(unsigned int *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an array of uniformly distributed unsigned 32bit integers.
 *  This method is significantly slower than the double precision methods
 *  and should only be used in conjunction with the SeedByArray method.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformArray(unsigned int *myArray, const Integer size)
{
    for (Integer i = 0; i < size; i++)
	myArray[i] = dsfmt_genrand_uint32(&dsfmt);
}

//------------------------------------------------------------------------------
//  void UniformArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an array of uniformly distributed random deviates in the range [0,1)
 *  The range includes 0.0 but excludes 1.0;
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformArray(Real *myArray, const Integer size)
{
     dsfmt_fill_array_close_open(&dsfmt,(double*)myArray,size);
}

//------------------------------------------------------------------------------
//  void UniformPrimitiveArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an array of uniformly distributed random deviates in the range [1,2)
 *  The range includes 1.0 but excludes 2.0. This is the primitive MT generator
 *  that all other function calls are based upon. This is the fastest method
 *  for generating a random variate.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformPrimitiveArray(Real *myArray, const Integer size)
{
     dsfmt_fill_array_close1_open2(&dsfmt,(double*)myArray,size);
}

//------------------------------------------------------------------------------
//  void UniformOpenOpenArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an array of uniformly distributed random deviates in the range (0,1)
 *  The range excludes both 0.0 and 1.0. This is useful when you need to
 *  avoid a singularity at 0 or 1.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformOpenOpenArray(Real *myArray, const Integer size)
{
     dsfmt_fill_array_open_open(&dsfmt,(double*)myArray,size);
}

//------------------------------------------------------------------------------
//  void UniformOpenClosedArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an array of uniformly distributed random deviates in the range (0,1]
 *  The range excludes 0.0 but includes 1.0. This is useful when you need to
 *  avoid a singularity at 0.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformOpenClosedArray(Real *myArray, const Integer size)
{
     dsfmt_fill_array_open_close(&dsfmt,(double*)myArray,size);
}

//------------------------------------------------------------------------------
//  void UniformArray(Real *myArray, Real a, Real b, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns an array of uniformly distributed random deviates in the range [a,b)
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformArray(Real *myArray, const Integer size, 
	                         const Real a, const Real b)
{

     dsfmt_fill_array_close_open(&dsfmt,(double*)myArray,size);
     for (Integer i=0; i < size; i++)
     {
         myArray[i] = a + (b - a)*myArray[i];
     }
}

//------------------------------------------------------------------------------
//  void UniformOpenOpenArray(Real *myArray, const Integer size, Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an array of uniformly distributed random deviates in the range (a,b)
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformOpenOpenArray(Real *myArray, const Integer size, 
	                         const Real a, const Real b)
{

     dsfmt_fill_array_open_open(&dsfmt,(double*)myArray,size);
     for (Integer i=0; i < size; i++)
     {
         myArray[i] = a + (b - a)*myArray[i];
     }
}
//------------------------------------------------------------------------------
// void UniformOpenClosedArray(Real *myArray, const Integer size, 
//			       Real a, Real b)
//------------------------------------------------------------------------------
/**
 *  Returns an array of uniformly distributed random deviates in the range (a,b]
 *  The mean of this distribution is (a+b)/2.
 *  The variance of this distribution is (b-a)^2/12.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *  @param <a> Distribution start
 *  @param <b> Distribution end
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::UniformOpenClosedArray(Real *myArray, const Integer size, 
				          const Real a, const Real b)
{

     dsfmt_fill_array_open_close(&dsfmt,(double*)myArray,size);
     for (Integer i=0; i < size; i++)
     {
         myArray[i] = a + (b - a)*myArray[i];
     }
}

//------------------------------------------------------------------------------
//  void GaussianArray(Real *myArray, const Integer size)
//------------------------------------------------------------------------------
/**
 *  Returns a normally distributed Gaussian random deviate (zero mean, unit var)
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::GaussianArray(Real *myArray, const Integer size)
{
     for (Integer i=0; i < size; i++)
     {
         myArray[i] = Gaussian();
     }
}

//------------------------------------------------------------------------------
//  void GaussianArray(Real *myArray, const Integer size,
//	                         const Real mean, const Real stdev)
//------------------------------------------------------------------------------
/**
 *  Returns an array of normally distributed Gaussian random deviates 
 *  with specified mean and variance.
 *
 *  @param <myArray> Pointer to array where random deviates will be stored
 *  @param <size> size of the array of deviates
 *  @param <mean> Mean of Gaussian distribution
 *  @param <stdev> Standard deviation of Gaussian distribution
 *
 */
//------------------------------------------------------------------------------
void RandomNumber::GaussianArray(Real *myArray, const Integer size,
	                         const Real mean, const Real stdev)
{
     for (Integer i=0; i < size; i++)
     {
         myArray[i] = Gaussian() * stdev + mean;
     }
}